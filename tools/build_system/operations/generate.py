"""
Implementation of the "build" command.
"""

import argparse
import logging
from pathlib import Path

import splat.scripts.split as splat_split
import splat.segtypes.common as splat_segtypes
from splat.segtypes.linker_entry import LinkerEntry

from build_system import ninja_syntax
from build_system.env import Environment
from .clean import clean
from .split import split

LOG = logging.getLogger(__name__)


def add_subparser(subparsers):
    """
    Add the argument parser for the command to the action object for
    the main parser.
    """
    parser: argparse.ArgumentParser = subparsers.add_parser(
        "generate",
        help="Generates the Ninja build script for the project.",
        description="Generates the Ninja build script for the project.",
    )
    parser.set_defaults(func=_generate_cli)


def _generate_cli(env: Environment, args):
    """
    Handle the "generate" command of the CLI.
    """
    generate(env)
    LOG.info("Done generating build script.")
    LOG.info("")
    LOG.info("Use `ninja` at the root of the repository to build the project.")


def generate(env: Environment, clean_first: bool = True):
    """
    Generate the Ninja build script for the project.
    """
    if clean_first:
        LOG.info("Cleaning build artifacts.")
        clean(env)

    # Regardless of flags, remove any existing build script.
    env.files.build_script.unlink(missing_ok=True)

    # If we can't detect that we've previously split the binary, distclean the repo first
    # to make sure we're in a good state before trying to build.
    split(env, clean_first=not env.previously_split())

    # Retrieve the linker entries generated by `splat` and read them to create
    # our build script.
    linker_entries: list[LinkerEntry] = [
        entry
        for entry in splat_split.linker_writer.entries
        if entry.segment.type[0] != "." and entry.object_path is not None
    ]

    LOG.debug("C Compiler Command:    %s", env.generate_c_compiler_cmd())
    LOG.debug("CXX Compiler Command:  %s", env.generate_cxx_compiler_cmd())
    LOG.debug("AS Command:            %s", env.generate_assembler_cmd())
    LOG.debug("LD Command:            %s", env.generate_linker_cmd())

    with env.files.build_script.open("w") as f:
        ninja = ninja_syntax.Writer(f)

        # Create rules for ninja build steps.
        ninja.rule(
            name="cc",
            description="CC          $in",
            command=f"{env.generate_c_compiler_cmd()} $in -o $out",
        )
        ninja.rule(
            name="cxx",
            description="CXX         $in",
            command=f"{env.generate_cxx_compiler_cmd()} $in -o $out",
        )
        ninja.rule(
            name="as",
            description="ASSEMBLE    $in",
            command=f"{env.generate_assembler_cmd()} $in -o $out",
        )
        ninja.rule(
            name="ld",
            description="LINK        $in",
            command=f"{env.generate_linker_cmd()} -T $in -o $out",
        )
        ninja.rule(
            name="elf",
            description="ELF         $in",
            command=f"{env.toolchain.objcopy_cmd} $in $out -O binary",
        )
        ninja.rule(
            name="check",
            description="CHECK       $in",
            command="./configure.py check --binary $in --output $out",
        )
        ninja.rule(
            name="progress",
            description="PROGRESS    $in",
            command="./configure.py progress --map-file $in --output $out",
        )

        built_objects: set[Path] = set()
        # Add each object to the build script according to its segment type.
        for entry in linker_entries:
            segment = entry.segment

            if _is_assemblable(segment):
                rule = "as"
            elif _is_c_code(segment):
                rule = "cc"
            elif _is_cxx_code(segment):
                rule = "cxx"
            else:
                raise AssertionError(f"Unknown segment type {type(segment)}!")

            _add_build_rule(ninja, entry.object_path, rule, entry.src_paths)
            if entry.object_path.suffix == ".o":
                built_objects.add(entry.object_path)

        # Add the linker step.
        ninja.build(
            outputs=[str(env.files.pre_elf)],
            rule="ld",
            inputs=[str(env.files.ldscript)],
            implicit=[str(obj) for obj in built_objects],
            implicit_outputs=[str(env.files.ldmap)],
        )

        # Add the final object step.
        ninja.build(
            outputs=[str(env.files.final_elf)],
            rule="elf",
            inputs=[str(env.files.pre_elf)],
        )

        # Add a step to ensure the new binary matches.
        ninja.build(
            outputs=[str(env.directories.build / "build.sha1")],
            rule="check",
            inputs=[str(env.files.final_elf)],
        )

        # Add a step to print binary progress if matching.
        ninja.build(
            outputs=[str(env.directories.build / "progress.txt")],
            rule="progress",
            inputs=[str(env.files.ldmap)],
            implicit=[str(env.directories.build / "build.sha1")],
        )


def _add_build_rule(
    ninja: ninja_syntax.Writer, output: Path, rule: str, inputs: list[Path]
):
    """
    Add a build with the given output and inputs to the Ninja script.
    """
    ninja.build(outputs=[str(output)], rule=rule, inputs=[str(p) for p in inputs])


def _is_assemblable(segment: splat_segtypes.segment.Segment) -> bool:
    """
    Determine if the `splat` segment should be fed to the assembler directly.
    """
    assemblable_types = (
        splat_segtypes.asm.CommonSegAsm,
        splat_segtypes.data.CommonSegData,
        splat_segtypes.databin.CommonSegDatabin,
        splat_segtypes.rodatabin.CommonSegRodatabin,
    )
    return isinstance(segment, assemblable_types)


def _is_c_code(segment: splat_segtypes.segment.Segment) -> bool:
    """
    Determine if the `splat` segment should be fed to the C compiler.
    """
    return isinstance(segment, splat_segtypes.c.CommonSegC)


def _is_cxx_code(segment: splat_segtypes.segment.Segment) -> bool:
    """
    Determine if the `splat` segment should be fed to the C++ compiler.
    """
    return isinstance(segment, splat_segtypes.cpp.CommonSegCpp)
